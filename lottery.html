<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"
    />
    <link rel="stylesheet" href="./asset/index.css" />
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="./asset/elementui.js"></script>
  </head>
  <body>
    <div id="root">
      <div class="header">
        <img class="header-img01" src="./asset/header01.png" />
        <img class="header-img02" src="./asset/header02.png" />
      </div>
      <div id="container">
        <svg id="svg1" style="width: 900; height: 600"></svg>
        <svg id="svg2" style="width: 900; height: 400"></svg>
        <svg id="svg3" style="width: 600; height: 600"></svg>
      </div>
      <div class="buttonGroup">
        <template>
          <el-radio @change="handleCountrySelection" v-model="countrySelection" label="US">United States</el-radio>
          <el-radio @change="handleCountrySelection" v-model="countrySelection" label="CN">China</el-radio>
          <el-radio @change="handleCountrySelection" v-model="countrySelection" label="TW">Taiwan</el-radio>
        </template>
      </div>
      <div id="my_dataviz2"></div>
      <div v-if="showLocationInfoBox" id="locationInfoBox">
        <div>Location：{{locationInfoBoxDataSelected.province}}</div>
        <div>
          Number of Occurrence：{{locationInfoBoxDataSelected?.list?.length}}
        </div>
      </div>
      <div v-if="showPlotChartInfoBox" id="plotInfoBox">
        <div>Year：{{plotInfoBoxDataSelected.year}}</div>
        <div>Number：{{plotInfoBoxDataSelected.number}}</div>
        <div>
          Number of Occurrence：{{plotInfoBoxDataSelected?.list?.length}}
        </div>
        <div>
          Month：
          <div v-for="item in plotInfoBoxDataSelected?.list" :key="item">
            {{item}}
          </div>
        </div>
      </div>
      <div class="bottom-container">
        <el-card class="box-card">
          <div>Lottery Simulator</div>
          <div style="font-size: 10px; color: gray">
            Please insert six numbers to see how lucky you are. The result would
            tell you how much you might win compared to the history.
          </div>
          <div>
            <el-input
              maxlength="2"
              class="inputNum"
              v-model="num01"
              placeholder=""
            ></el-input>
            <el-input
              maxlength="2"
              class="inputNum"
              v-model="num02"
              placeholder=""
            ></el-input>
            <el-input
              maxlength="2"
              class="inputNum"
              v-model="num03"
              placeholder=""
            ></el-input>
            <el-input
              maxlength="2"
              class="inputNum"
              v-model="num04"
              placeholder=""
            ></el-input>
            <el-input
              maxlength="2"
              class="inputNum"
              v-model="num05"
              placeholder=""
            ></el-input>
            <el-input
              maxlength="2"
              class="inputNum"
              v-model="num06"
              placeholder=""
            ></el-input>
            <el-button @click="handleBacktest" type="success" plain
              >Try</el-button
            >
          </div>
          <div class="prizeContainer">
            <template>
              <el-table :data="tableData" style="width: 100%">
                <el-table-column prop="year" label="Date" width="180">
                </el-table-column>
                <el-table-column prop="isWinning" label="Prize" width="180">
                </el-table-column>
                <el-table-column prop="winningNumber" label="Detail">
                </el-table-column>
              </el-table>
            </template>
          </div>
        </el-card>
        <div id="hint-container"></div>
      </div>
    </div>
  </body>
  <script>
    const app = new Vue({
      el: "#root",
      created: async function () {
        this.resetMap();
        this.usLotteryChartData = await this.processUSData();
        this.twLotteryChartData = await this.processTWData();
        this.cnLotteryChartData = await this.processCNData();
        this.renderPlotChart();

        this.typeWriter();
      },
      data: {
        checkList: ["United States", "China", "Taiwan"],
        twLotteryChartData: "",
        usLotteryChartData: "",
        cnLotteryChartData: "",
        twhistoryPrizeInfo: [],
        ushistoryPrizeInfo: [],
        cnhistoryPrizeInfo: [],
        twplotInfoBoxData: "",
        usplotInfoBoxData: "",
        cnplotInfoBoxData: "",
        countrySelection: "US",
        num01: "",
        num02: "",
        num03: "",
        num04: "",
        num05: "",
        num06: "",
        tableData: [],
        plotInfoBoxDataSelected: "",
        showPlotChartInfoBox: false,
        locationInfoBoxData: "",
        locationInfoBoxDataSelected: "",
        showLocationInfoBox: false,
        typingTimeout: "",
      },
      computed: {
        numberGroup() {
          return [
            this.num01,
            this.num02,
            this.num03,
            this.num04,
            this.num05,
            this.num06,
          ];
        },
      },
      methods: {
        handleCountrySelection() {
          this.renderPlotChart();
        },
        typeWriter() {
          const context = this;
          if (this.typingTimeout) {
            clearTimeout(this.typingTimeout);
          }
          document.getElementById("hint-container").innerHTML = "";
          var i = 0;
          var txt = `
                      Jackpot ! It is only 0.001% to
                      win this fortune. Lottery is essentially a type of Gambling.
                      Please use your money carefully. As it shows in some of the
                      social studies, people with financial problems, especially in
                      the pendemic period, are tend to be addicted to small gambling
                      like Lottery. They would: · gamble regardless of their financial
                      situation and that of their families · become heavily indebted,
                      resulting in family problems (including child abuse and suicide)
                      · sometimes connect with gangs, usury and other social problems`; /* The text */
          var speed = 50; /* The speed/duration of the effect in milliseconds */
          function doTyping() {
            if (i < txt.length) {
              document.getElementById("hint-container").innerHTML += txt.charAt(
                i
              );
              i++;
              context.typingTimeout = setTimeout(doTyping, speed);
            }
          }
          doTyping();
        },
        handleCloseInfoBox() {
          this.showPlotChartInfoBox = false;
        },
        handleBacktest() {
          if (
            this.numberGroup.filter((num) => num && num >= 0 && num <= 49)
              .length < 6
          ) {
            alert(
              "The number is incomplete, and the number must between 1 - 49."
            );
            return;
          }
          if (new Set(this.numberGroup).size < 6) {
            alert("Number Duplicate.");
            return;
          }
          const c = [];
          this.twhistoryPrizeInfo.forEach((period) => {
            const result = compareTWNumber(
              this.numberGroup,
              period.numberArray,
              period.year
            );
            if (result.isWinning !== "Not winning.") {
              c.push(result);
              this.tableData = c;
            }
          });
          this.typeWriter();
        },
        async handleCheckboxChange(e) {
          //const list = e.slice(0, e.length);
        },
        async processUSData() {
          const numInfo = {};
          const numInfoDetail = {};
          const chartNumInfo = [];
          const data = await d3.csv("./data/us/number.csv");
          data.forEach((ele) => {
            const year = ele.year.slice(6, 10);
            const numberArray = ele.numbers.split(" - ");
            // 中獎回測資料
            this.ushistoryPrizeInfo.push({
              numberArray,
              specialNum: ele.specialNumber,
              year: ele.year,
            });
            // 圖表資料
            numberArray.forEach((num) => {
              // 記錄開出次數
              if (!numInfo[year]) {
                numInfo[year] = {};
              }
              if (!numInfo[year][num]) {
                numInfo[year][num] = 0;
              }
              numInfo[year][num] += 1;
              // 記錄開出月份
              if (!numInfoDetail[year]) {
                numInfoDetail[year] = {};
              }
              if (!numInfoDetail[year][num]) {
                numInfoDetail[year][num] = [];
              }
              numInfoDetail[year][num].push(ele.year);
            });
          });
          delete numInfo[""];
          delete numInfoDetail[""];
          this.usplotInfoBoxData = numInfoDetail;
          Object.keys(numInfo).forEach((year) => {
            Object.keys(numInfo[year]).forEach((number) => {
              chartNumInfo.push({
                year,
                number,
                count: numInfo[year][number],
              });
            });
          });
          return chartNumInfo;
        },
        async processCNData() {
          const numInfo = {};
          const numInfoDetail = {};
          const chartNumInfo = [];
          const data = await d3.csv("./data/cn/number.csv");
          data.forEach((ele) => {
            const year = ele['开奖日期'].slice(0, 4);
            let numberArray = ele['红球'].match(/.{1,2}/g);
            // 中獎回測資料
            this.cnhistoryPrizeInfo.push({
              numberArray,
              specialNum: ele['蓝球'],
              year: ele.year,
            });
            // 圖表資料
            numberArray.forEach((num) => {
              // 記錄開出次數
              if (!numInfo[year]) {
                numInfo[year] = {};
              }
              if (!numInfo[year][num]) {
                numInfo[year][num] = 0;
              }
              numInfo[year][num] += 1;
              // 記錄開出月份
              if (!numInfoDetail[year]) {
                numInfoDetail[year] = {};
              }
              if (!numInfoDetail[year][num]) {
                numInfoDetail[year][num] = [];
              }
              numInfoDetail[year][num].push(ele['开奖日期']);
            });
          });
          this.cnplotInfoBoxData = numInfoDetail;
          Object.keys(numInfo).forEach((year) => {
            Object.keys(numInfo[year]).forEach((number) => {
              chartNumInfo.push({
                year,
                number,
                count: numInfo[year][number],
              });
            });
          });
          return chartNumInfo;
        },
        async processTWData() {
          const numInfo = {};
          const numInfoDetail = {};
          const chartNumInfo = [];
          const data = await d3.csv("./data/tw/tw-number.csv");
          data.forEach((ele) => {
            const year = ele.year.slice(0, 4);
            let numberArray = ele.numbers.match(/.{1,2}/g);
            // 中獎回測資料
            this.twhistoryPrizeInfo.push({
              numberArray,
              specialNum: numberArray[6],
              year: ele.year,
            });
            // 圖表資料
            numberArray.forEach((num) => {
              // 記錄開出次數
              if (!numInfo[year]) {
                numInfo[year] = {};
              }
              if (!numInfo[year][num]) {
                numInfo[year][num] = 0;
              }
              numInfo[year][num] += 1;
              // 記錄開出月份
              if (!numInfoDetail[year]) {
                numInfoDetail[year] = {};
              }
              if (!numInfoDetail[year][num]) {
                numInfoDetail[year][num] = [];
              }
              numInfoDetail[year][num].push(ele.year);
            });
          });
          this.twplotInfoBoxData = numInfoDetail;
          Object.keys(numInfo).forEach((year) => {
            Object.keys(numInfo[year]).forEach((number) => {
              chartNumInfo.push({
                year,
                number,
                count: numInfo[year][number],
              });
            });
          });
          return chartNumInfo;
        },
        async renderUSMap({ scale }) {
          var width = 1200;
          var height = 500;

          // D3 Projection
          var projection = d3
            .geoAlbersUsa()
            .translate([width / 5, height / 2])
            .scale([scale]);

          // Define path generator
          var path = d3
            .geoPath() // path generator that will convert GeoJSON to SVG paths
            .projection(projection); // tell path generator to use albersUsa projection
          const context = this;
          d3.json("./data/us/state.json").then(function (json) {
            d3.select("#svg1")
              .selectAll("path")
              .data(json.features)
              .enter()
              .append("path")
              .attr("d", path)
              .attr("id", (d) => d.properties.name.replace(/\s/g, ""))
              .style("stroke", "#fff")
              .style("stroke-width", "1")
              .style("fill", "rgb(213,222,217)")
              .on("mouseover", function ({ properties }) {
                context.showLocationInfoBox = true;
                d3.select(this).attr("fill-opacity", 0.6);
                context.locationInfoBoxDataSelected = {
                  province: properties.name,
                  list: new Array(locationData[properties.name]),
                };
              })
              .on("mouseout", function (d) {
                d3.select(this).attr("fill-opacity", 1);
                context.showLocationInfoBox = false;
              });
          });

          const locationData = await d3.json("./data/us/location.json");
          Object.keys(locationData).forEach((state) => {
            d3.select(`#${state.replace(/\s/g, "")}`).style(
              "fill",
              usColorGrade(locationData[state])
            );
          });
        },
        async renderCNMap({ scale }) {
          const context = this;
          var width = 1200;
          var height = 500;

          // D3 Projection
          var projection = d3
            .geoMercator()
            .center([110, 25])
            .scale([scale])
            .translate([width / 4.5, 350])
            .precision([0.1]);

          // Define path generator
          var path = d3
            .geoPath() // path generator that will convert GeoJSON to SVG paths
            .projection(projection); // tell path generator to use albersUsa projection

          //Create SVG element and append map to the SVG

          d3.json("./data/cn/state.json").then(function (json) {
            d3.select("#svg2")
              .selectAll("path")
              .data(json.features)
              .enter()
              .append("path")
              .attr("d", path)
              .attr("id", (d) => d.properties.name)
              .style("stroke", "#fff")
              .style("stroke-width", "1")
              .style("fill", "rgb(213,222,217)")
              .on("mouseover", function ({ properties }) {
                context.showLocationInfoBox = true;
                d3.select(this).attr("fill-opacity", 0.6);
                context.locationInfoBoxDataSelected = {
                  province: properties.name,
                  list: new Array(resultDetail[properties.name]),
                };
              })
              .on("mouseout", function (d) {
                d3.select(this).attr("fill-opacity", 1);
                context.showLocationInfoBox = false;
              });
          });
          const locationData = await d3.csv("./data/cn/location.csv");
          const resultDetail = {};
          const result = locationData.map((d) =>
            d.prizes
              .split(/注/g)
              .map((word) => word.split(/(?=\d)/g))
              .map((item) => {
                if (item.length === 3) {
                  item[1] = item[1] + item[2];
                  item.pop();
                }
                return item;
              })
          );
          result.forEach((_stateData) => {
            _stateData.forEach((stateData) => {
              const province = stateData[0];
              const provinceNum = stateData[1];
              if (resultDetail[province]) {
                resultDetail[province] += Number(provinceNum);
              } else {
                resultDetail[province] = Number(provinceNum);
              }
            });
          });
          String.prototype.regexIndexOf = function (regex, startpos) {
            var indexOf = this.substring(startpos || 0).search(regex);
            return indexOf >= 0 ? indexOf + (startpos || 0) : indexOf;
          };
          Object.keys(resultDetail).forEach((key) => {
            if (key.regexIndexOf(/。|；|�|为|共|null/g) !== -1) {
              delete resultDetail[key];
            }
          });
          Object.keys(resultDetail).forEach((state) => {
            d3.select(`#${state}`).style("fill", () =>
              cnColorGrade(resultDetail[state])
            );
          });
        },
        renderTWMap({ scale }) {
          const context = this;
          d3.json("./data/tw/state.json").then(function (topodata) {
            const features = topojson.feature(topodata, topodata.objects.county)
              .features;
            const projection = d3
              .geoMercator()
              .center([118, 27])
              .scale([scale])
              .translate([0, 0])
              .precision([0.1]);
            const path = d3.geoPath().projection(projection);
            d3.select("#svg3")
              .selectAll("path")
              .data(features)
              .enter()
              .append("path")
              .attr("d", path)
              .attr("id", ({ properties }) => properties.C_Name)
              .attr("fill", "teal")
              .on("mouseover", function ({ properties }) {
                d3.select(this).attr("fill-opacity", 0.6);
                context.locationInfoBoxDataSelected = {
                  province: properties.C_Name,
                  list: context.locationInfoBoxData[properties.C_Name],
                };
                context.showLocationInfoBox = true;
              })
              .on("mouseout", function (d) {
                d3.select(this).attr("fill-opacity", 1);
                context.showLocationInfoBox = false;
              });
          });
          d3.csv("./data/tw/tw-location.csv").then((data) => {
            const provinceCount = {};
            const detailProvinceCount = {};
            data.forEach((lottery) => {
              const province = lottery["province"];
              if (provinceCount[province]) {
                provinceCount[province] += 1;
              } else {
                provinceCount[province] = 1;
              }

              if (detailProvinceCount[province]) {
                detailProvinceCount[province].push(lottery);
              } else {
                detailProvinceCount[province] = [lottery];
              }
            });
            this.locationInfoBoxData = detailProvinceCount;
            Object.keys(provinceCount).forEach((province) => {
              d3.select(`#${province}`).attr(
                "fill",
                twColorGrade(provinceCount[province])
              );
            });
          });
        },
        resetMap() {
          document.querySelector("#svg1").innerHTML = "";
          document.querySelector("#svg2").innerHTML = "";
          document.querySelector("#svg3").innerHTML = "";
          this.renderUSMap({
            scale: 600,
          });
          this.renderCNMap({
            scale: 400,
          });
          this.renderTWMap({
            scale: 4000,
          });
        },
        renderPlotChart() {
          document.querySelector('#my_dataviz2').innerHTML = "";
          var margin = { top: 10, right: 30, bottom: 40, left: 50 },
            width = 1120 - margin.left - margin.right,
            height = 520 - margin.top - margin.bottom;

          // append the svg object to the body of the page
          var Svg = d3
            .select("#my_dataviz2")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr(
              "transform",
              "translate(" + margin.left + "," + margin.top + ")"
            );

          //Read the data
          d3.csv(
            "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/iris.csv"
          ).then(async (data) => {
            // Add X axis
            var x = d3.scaleLinear().domain([0, 60]).range([0, width]);
            Svg.append("g")
              .attr("transform", "translate(0," + height + ")")
              .call(
                d3
                  .axisBottom(x)
                  .tickSize(-height * 1.3)
                  .ticks(60)
              )
              .select(".domain")
              .remove();

            // Add Y axis
            var y = d3
              .scaleLinear()
              .domain([2003, 2020])
              .range([height, 0])
              .nice();
            Svg.append("g")
              .call(
                d3
                  .axisLeft(y)
                  .tickSize(-width * 1.3)
                  .ticks(20)
              )
              .select(".domain")
              .remove();

            // Customization
            Svg.selectAll(".tick line").attr("stroke", "#EBEBEB");

            // Add X axis label:
            Svg.append("text")
              .attr("text-anchor", "end")
              .attr("x", width)
              .attr("y", height + margin.top + 20)
              .text("Numbers");

            // Y axis label:
            Svg.append("text")
              .attr("text-anchor", "end")
              .attr("transform", "rotate(-90)")
              .attr("y", -margin.left + 20)
              .attr("x", -margin.top)
              .text("Years");

            // Color scale: give me a specie name, I return a color
            var color = d3
              .scaleOrdinal()
              .domain(["setosa", "versicolor", "virginica"])
              .range(["#402D54", "#D18975", "#8FD175"]);
            // Add dots
            const dotGroup = Svg.append("g").attr("id", "dotGroup");
            const context = this;
            dotGroup
              .selectAll("circle")
              .data(
                this.countrySelection === 'US'
                  ? this.usLotteryChartData
                  : this.countrySelection === 'TW'
                  ? this.twLotteryChartData
                  : this.cnLotteryChartData
              )
              .enter()
              .append("circle")
              .attr("cx", function (d) {
                return x(Number(d.number));
              })
              .attr("cy", function (d) {
                return y(Number(d.year));
              })
              .attr("r", 6)
              .style("fill", (d) => twColorGrade(d.count))
              .on("mouseover", function (d) {
                context.showPlotChartInfoBox = true;
                d3.select(this).attr("fill-opacity", 0.6);
                context.plotInfoBoxDataSelected = {
                  number: d.number,
                  year: d.year,
                  list: context.countrySelection === 'US'
                    ? context.usplotInfoBoxData[d.year][d.number]
                    : context.countrySelection === 'TW'
                    ? context.twplotInfoBoxData[d.year][d.number]
                    : context.cnplotInfoBoxData[d.year][d.number],
                };
              })
              .on("mouseout", function (d) {
                context.showPlotChartInfoBox = false;
                d3.select(this).attr("fill-opacity", 1);
              });
          });
        },
      },
    });

    const usColorGrade = (count) => {
      if (count <= 5) {
        return "#1de9b6";
      }
      if (count < 10) {
        return "#fff59d";
      }
      if (count < 15) {
        return "#ffcc80";
      }
      if (count < 25) {
        return "#ff7043";
      }
      if (count > 25) {
        return "#ab47bc";
      }
    };

    const cnColorGrade = (count) => {
      if (count <= 50) {
        return "#1de9b6";
      }
      if (count < 100) {
        return "#fff59d";
      }
      if (count < 150) {
        return "#ffcc80";
      }
      if (count < 250) {
        return "#ff7043";
      }
      if (count > 250) {
        return "#ab47bc";
      }
    };

    const twColorGrade = (count) => {
      if (count <= 5) {
        return "#1de9b6";
      }
      if (count > 5 && count <= 10) {
        return "#fff59d";
      }
      if (count > 10 && count <= 15) {
        return "#ffcc80";
      }
      if (count > 15 && count <= 20) {
        return "#ff7043";
      }
      if (count > 20) {
        return "#ab47bc";
      }
    };

    function compareTWNumber(array1, array2, year) {
      var result = {};

      array1
        .map((d) => Number(d))
        .forEach(function (item) {
          result[item] = 0;
        });

      array2
        .map((d) => Number(d))
        .forEach(function (item) {
          if (result.hasOwnProperty(item)) {
            result[item]++;
          }
        });
      const matchNumberCount = Object.entries(result)
        .map((arr) => arr[1])
        .reduce((a, b) => a + b);
      const hasSpecial = result[array2[6]] === 1;
      function isWinning() {
        if (matchNumberCount === 3 && hasSpecial) {
          return "Seventh Prize NTD 400";
        }
        if (matchNumberCount === 3 && !hasSpecial) {
          return "General Prize NTD 400";
        }
        if (matchNumberCount === 4 && hasSpecial) {
          return "Sixth Prize NTD 1000";
        }
        if (matchNumberCount === 4 && !hasSpecial) {
          return "Fifth Prize NTD 2000";
        }
        if (matchNumberCount === 5 && hasSpecial) {
          return "Forth Prize Around NTD 10 thousand";
        }
        if (matchNumberCount === 5 && !hasSpecial) {
          return "Third Prize Around NTD 50 thousand";
        }
        if (matchNumberCount === 6 && hasSpecial) {
          return "Second Prize Around NTD 3 Million";
        }
        if (matchNumberCount === 6 && !hasSpecial) {
          return "Jackpot!! Over NTD 100 Million";
        }
        return "Not winning.";
      }

      return {
        winningNumber: JSON.stringify(
          Object.entries(result)
            .filter((d) => d[1] === 1)
            .map((d) => d[0])
        ),
        matchNumberCount,
        specialNum: array2[6],
        hasSpecial,
        isWinning: isWinning(),
        year,
      };
    }
  </script>
</html>
